# Examples
Here are some examples of cool stuff you can do with the built in mods!

## Fixed return value
- Scenario: there is a class `FancyStuff` with a `bool IsUnlocked()` method. Let's mod it so that it **always returns true.**

```
module.exports = {
  /*...game and dump sections omitted for brevity, just keep the autogenerated ones!...*/
  "hooks": {
    methods: [{
      className: "FancyStuff",
      name: "IsUnlocked",
      trampolineHookBytes: 6,
      mods: [{
        type: "fixedReturnValue", 
        args: "true"
      }]
    }]
  },
}
```

- Scenario: there is a class `ValidatedStuff` with a `void ValidateSomething()` method. Let's mod it so that the **validation does nothing and just let's you through.**
```
module.exports = {
  /*...game and dump sections omitted for brevity, just keep the autogenerated ones!...*/
  "hooks": {
    methods: [{
      className: "ValidatedStuff",
      name: "ValidateSomething",
      trampolineHookBytes: 6,
      mods: [{
        type: "fixedReturnValue", 
        args: ""
      }]
    }]
  },
}
```

## Replace arguments
- Scenario: there is a class `Player` with a `void SetCoins(int coins)` method. Let's mod it so that the setter **always sets your coins to 999999.**
```
module.exports = {
  /*...game and dump sections omitted for brevity, just keep the autogenerated ones!...*/
  "hooks": {
    methods: [{
      className: "Player",
      name: "SetCoins",
      trampolineHookBytes: 6,
      mods: [{
        type: "replaceArguments", 
        args: ["999999"]
      }]
    }]
  },
}
```

## Path memory hack

- Scenario: there is a class `Fighter` with a field `FighterStatus Status`, that has a field `float Health`. Let's mod it so that the `Fighter.Status.Health` field is **always at 100**.

```
module.exports = {
  /*...game and dump sections omitted for brevity, just keep the autogenerated ones!...*/
  "hooks": {
    methods: [{
      className: "Fighter",
      name: "AnyMethodInFighterClass",
      trampolineHookBytes: 6,
      mods: [{
        type: "pathMemoryHack", 
        args: { 
          paths: [{ 
            name: "The health of the fighter", //Optional, a descriptive name for the path
            path: "Status.Health",
            value: "100"
          }]
        }
      }]
    }]
  },
}
```

If you'd like to set different values for that field in different times, just don't specify the `value` property in the hook. You will be able to insert the value you want via de mod console at any given time.

### Why are we hooking `AnyMethodInFighterClass`?
This mod is not a method hook but a path memory hook. Nevertheless, we need to hook a method to get a reference to the object you'd like to mod: the `this` pointer. You do this by hooking _any method in the Fighter class_. Try to choose one that gets called often (most of them are) so you get the pointer quickly! 

## Replace implementation
- Scenario: there is a really complex class `ComplexClass` with a really `int ComplexMethod(int anIntParam)` method. You want to mod it, but the **basic built in mods are not enough**. Let's mod it has a new implementation.
This one is more advanced, as you need to write valid C++ code. The function signature (parameters + return) gets autogenerated for you to avoid any mistakes. You just have to take care of the function body. 
You have access to the parameters of the original function with the same names.
If you need to use the original function behaviour, you can call it via `original_ComplexClass_ComplexMethod(anInt);` or more generally `original_[class name]_[method name]([parameters]);`

```
module.exports = {
  /*...game and dump sections omitted for brevity, just keep the autogenerated ones!...*/
  "hooks": {
    methods: [{
      className: "FancyStuff",
      name: "IsUnlocked",
      trampolineHookBytes: 6,
      mods: [{
        type: "fixedReturnValue", 
        args: `
          bool someFancyBoolean = anIntParam > 10;
          if(someFancyBoolean) return 1;
          //Call original ComplexClass.ComplexMethod with another argument
          int aNewArgument = 123;
          original_ComplexClass_ComplexMethod(aNewArgument);
          /*keep doing fancy c++ stuff*/
          return 2; 
        `
      }]
    }]
  },
}
```

# Notes
- You can hook all the instance methods you want in all public classes, concrete or abstract.
- Static methods and field hooks are currently not supported.
- Even though the field `mods` is an array, currently just one mod per method is supported.
